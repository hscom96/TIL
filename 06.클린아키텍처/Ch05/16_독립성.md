# 16장. 독립성

## 좋은 아키 텍처가 지원하는 것

### 1) 유스케이스

- 시스템 아키 텍처는 시스템의도를 지원해야한다.
- 즉 장바구니 애플리케이션이면 장바구니 관련된 유스케이스를 지원해야한다는 뜻
- 좋은 아키텍처는 행위를 명확히 하고 외부로 드러내며, 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만듬 (21장 "소리치는 아키텍처" 참조)

### 2) 운영

- 아키텍처는 운영에서 더 실질적인 역할을 맡음
- 운영 작업(초당 ~명 고객처리 등등)을 허용할 수 있는 형태로 아키텍처 구조화해야함. -> 마이크로 서비스, 모노리틱, 다중스레드 등등
- 요구사항이 바뀌어도 기술 스펙트럼을 전환 쉽게 하기 위해서 -> 각 컴포넌트 적절히 격리하고 컴포넌트 간 통신 방식을 특정 형태로 제한한다.

### 3) 개발

> - 콘웨이 법칙 ?
    >
- 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

- 각 팀이 독립적으로 행동하기 편한 아키텍처를 만들어 개발하는 동안 팀들이 서로 방해하지 않도록 해야함.
- 잘 격리된 독립적으로 개발 가능한 컴포넌트 단위로 시스템 분할해야함.

### 4) 배포

- 좋은 아키텍처 목표는 **'즉각적인 배포'**

### 5) 선택사항 열어놓기

- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 떄 어떤 방향으로든 쉽게 변경할 수 있도록함.

<br/>

## 결합 분리

![picture 1](../images/5fb0f76153325962c38b53834f8fdb493990e9a2f10a80cb045ede5c90a38112.png)

### 계층 결합 분리

- **다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다**. -> **단일 책임원칙, 공통 폐쇄 원칙** 적용하자!
- => 수평적인 계층으로 분리됨!
- 예시
    -
        1. UI vs 업무 규칙

        - 서로 독립적으로 변경 가능
    -
        2. 업무 규칙 분리 (애플리케이션 관련 여부)

        - 애플리케이션과 관련된 업무 규칙 (ex 입력 유효성 검사)
        - 애플리케이션과 독립적인 업무 규칙 (ex 이자 계산, 재고품 집계 등..)
    -
        3. 데이터베이스 vs 업무규칙, ui

        - 서로 다른 이유로 변경

### 유스케이스 결합 분리

- 유스케이스도 서로 다른 이유로 변경되는 경우가 있다.
- => 수직적인 유스케이스로 분리됨!
- 예시
    - 주문 유스케이스 (추가 vs 삭제)

<br/>

## 결합 분리 장점

### 1. 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이 간섭 줄어듬

### 2. 배포 독립성

- 배포 측면에서 유연성 생김

<br/>

## 중복

중복에는 2가지 종류(진짜, 거짓)가 존재한다.

#### 진짜 중복

- **한 인스턴스가 변경되면, 동일한 변경을 모든 복사본에 반드시 적용** 해야 한다.
- -> 하나의 코드로 합치는것이 관리에 용이하다.

#### 거짓된 중복

- **중복으로 보이는 두 코드 영역이 서로 다른 속도와 다른 이유로 변경** 된다면 진짜 중복이 아니다.
- 시간이 지나면서 서로 다른 방향으로 분기할 가능성 높음
- 만약 통합한다면 나중에 다시 분리해야하는 수고 감수해야함

즉 유스케이스 분리, 통합할때 -> **진짜 중복인지 주의깊게 확인**하자!

<br/>

## 결합 분리 모드

#### 1. 소스 수준 분리 모드

- 소스 코드 모듈 사이의 의존성 제어 -> 하나의 모듈이 변해도 다른 모듈을 변경하거나 재컴파일 안해도됨
- 모든 컴포넌트가 같은 주소공간에서 실행됨.
- 메모리에는 하나의 실행파일만 로드.
- 통신 : 함수 호출
- 모노리틱 구조

#### 2. 배포 수준 분리 모드

- 배포 가능한 단위(jar 파일 / 공유 라이브러리)사이의 의존성을 제어 -> 한 모듈의 소스코드가 변해도 다른 모듈 재빌드하거나 재배포하지 않음
- 모든 컴포넌트가 같은 주소공간에서 실행됨.
- 통신 : 함수호출, 프로세스간통신, 공유메모리 등

#### 3. 서비스 수준 분리 모드

- 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적
- 통신 : 네트워크 패킷
- 마이크로서비스
- 단점 : 큰 단위에서 분리됨, 비용 많이든다.

<br/>

## 좋은 아키텍처는?

- 3개 중에 어느것이 좋은가? => 모른다. 프로젝트 성숙도에 따라 다르다.
- 모노리틱 구조로 태어나서 단일 파일로 배포되더라도 이후에 독립적으로 배포 가능한 단위, 마이크로 서비스 수준까지 성장하도록 만들어져야함.
- 좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호
