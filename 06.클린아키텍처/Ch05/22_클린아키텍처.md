# 22장. 클린 아키텍처

## 들어가며

육각형 아키텍처, DCI, BCE 등 여러가지 아키텍처가 있지만 목표는 모두 **관심사의 분리** 다.

- 모두 소프트웨어를 분리함으로써 이 목표를 달성 가능.
- 각각 업무 규칙을 위한 계층, 사용자와 시스템 인터페이스를 위한 계층을 반드시 포함한다.

<br/>

아키텍처는 시스템이 다음과 같은 특징을 지니도록 만든다.

- **프레임 워크 독립성** :
    - 아키텍처는 프레임워크의 존재 여부에 의존하지 않는다.
- **테스트 용이성** :
    - 업무 규칙은 UI, DB, 웹서버 등 요소가 없어도 테스트할 수 있다.
- **UI 독립성** :
    - 업무규칙을 변경하지 않은 채 UI를 쉽게 변경할 수 있다.
- **데이터베이스 독립성** :
    - 업무 규칙은 DB에 의존하지 않는다. (타 DB로 쉽게 교체가능)
- **모든 외부 에이전시에 대한 독립성** :
    - 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.

<br/>

## 의존성 규칙

![picture 5](../images/3c78f27baca8d354389f1e6aa334edbe21537638694c73b0299980ac8d0e2222.png)

- 안으로 들어갈수록 고수준 소프트웨어이다.
- 반드시 소스코드 의존성은 안쪽으로, 고수준 정책을 향해야한다.
    - 내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다. 함수, 클래스, 변수 등 외부 원에 선언된 어떤 이름도 언급하면 안된다.
- 외부 원에 위치한 어떤것도 내부의 원에 영향을 주어선 안됨

<br/>

## 엔티티

- 엔티티는 전사적인 **핵심 업무 규칙을 캡슐화** 한다.
- **엔티티 = 메서드만 가진 객체 or 데이터 구조 + 함수집합**
- 엔티티는 가장 일반적이며 **고수준인 규칙을 캡슐화** 한다.
- 운영 관점에서도 애플리케이션이 변경되도 엔티티에 영향을 주어선 안된다.

<br/>

## 유스케이스

- 유스케이스 계층은 **애플리케이션에 특화된 업무 규칙을 포함**
- 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스 목적을 달성하도록 이끈다.

### 주의사항

1. 이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안된다.
2. DB, UI, 또는 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서는 안된다. (유스케이스 계층은 이러한 관심사로부터 격리)

<br/>

## 인터페이스 어댑터

- 인터페이스 어댑터 계층은 일련의 어댑터들로 구성된다.

### 기능

1. 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 -> 외부 에이전시(DB, 웹)에게 가장 편한 형식으로 변환한다.

- MVC패턴 presenter, view, controller는 모두 인터페이스 어댑터 계층이다.
- 어떤 코드도 db에 대해 조금도 알아서는 안된다.

2. 데이터를 외부 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환

<br/>

## 프레임워크와 드라이버

- 가장 바깥쪽 계층으로 DB나 웹프레임워크 같은 도구로 구성
- 프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다.

<br/>

## 원은 네 개여야만하나?

- 예시일뿐 4개보다 더 많이 필요할 수도 있다.
- 단 어떤경우에도 **의존성 규칙은 적용된다.**
    - 소스코드 의존성은 항상 안쪽으로
    - 안쪽으로 이동할수록 가장 범용적이며 높은 수준을 가짐
    - 가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성

<br/>

## 경계횡단하기

> 위 그림 참조하자.

- **제어흐름**
    - 컨트롤러 -> 유스케이스 -> 프레젠터에서 실행
- **소스코드 의존성**
    - 각 의존성은 유스케이스를 향해 안쪽을 가리킨다.
- 소스코드 제어흐름과 의존성의 방향이 반대여야 하면? -> 의존성 역전 원칙을 사용!
    - 자바의 경우는 interface, 상속 사용

> 예를들어 유스케이스에서 프레젠터를 호출해야 한다면 외부 원 이름을 언급하면 안되는 의존성 규칙 때문에 직접 호출하면 안된다. 그대신 유스케이스는 내부 원의 인터페이스를 호출하고 외부 원의 프레젠터가 그 인터페이스를 구현한다.

<br/>

## 경계를 횡단하는 데이터는 어떤 모습인가?

- 경계를 가로질러 전달되는건 격리되어있는 간단한 데이터구조다.
    - ex) DTO, 함수 호출 인자, Map...
- 데이터 구조가 **어떤 의존성을 가져서 의존성 규칙을 위배하면 안된다.**
    - ex) 엔티티를 그대로 반환해서 DB row구조가 경계를 넘어 내부로 전달되면 -> 의존성 규칙 위배
- 데이터는 항상 **내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.**

<br/>

## 전형적인 시나리오 (웹)

![picture 6](../images/beed1322638e714198909d87d698e67aff92c8cc0a05bdf512ca661ad53af263.png)


<br/>

## 결론

- 계층을 분리하고 의존성 규칙을 준수하면 본질적으로 테스트하기 쉬운 시스템을 만들게 되며, 외부 요소가 구식이 되더라도 손쉽게 교체가능하다.
