# 25장. 계층과 경계

## 움퍼스 사냥 게임

![picture 3](../images/7f1115271eaa1f151ba7aefc1705b5c50c0d7698347edaafa0b9e84a8f7f57a4.png)

- **소스 코드 의존성**을 적절히 관리하면, UI 컴포넌트가 어떤 언어를 사용하더라도 게임 규칙을 재사용할 수 있다.

![picture 4](../images/f819926c8c87a954e53a63ed2afefc0786ae6835e20a3f3c0a8a770d0f146374.png)

- 게임 규칙이 다양한 종류의 데이터 저장소에 대해 알지 않기 위해서는 의존성 규칙을 준수해야한다.

<br/>

## 클린 아키텍처?

- UI에서 언어도 변경하고 싶을뿐만 아니라, 텍스트를 주고 받는 매커니즘 (ex. shell or 채팅 or 텍스트)을 다양하게 만들고 싶을 수 있다.
- ![picture 5](../images/f068797d6ef262384bddb7674c03f4651eb6f8a309f8c08581af48431fd2c48f.png)

- 점선으로 된 테두리는 API를 정의하는 **추상 컴포넌트**를 뜻하고, **각각 컴포넌트들이 이를 구현**.
- GameRules는 GameRules가 정의하고 Language가 구현하는 API를 이용해 Language와 통신한다.
    - 마찬가지로 Language도 Language가 정의하고 TextDelivery가 구현하는 API를 이용해 TextDelivery와 통신한다.
    - API는 구현하는 쪽이아닌 사용하는 쪽에 정의되고 소속된다.
- GameRules보면 GameRules 내부 코드에서 사용하고 Language 내부 코드에서 구현하는 다형적 Boundary 인터페이스를 발견할 수 있다.

![picture 6](../images/0a19e4936228f63869e14cf00966eb82f900032a04018aaffe7fb836c5d123b7.png)

- 모든 경우 해당 Boundary 인터페이스가 정의하는 API는 의존성 흐름의 상위에 위치한 컴포넌트에 속한다.
    - GameRules가 최상위 수준 정책을 가진 컴포넌트 -> 의존성 흐름을 보자
- 데이터 흐름을 두 개의 흐름으로 효과적으로 분리한다.
    - 왼쪽의 흐름은 사용자와의 통신에 관여
    - 오른쪽 흐름은 데이터 영속성에 관여 두 흐름은 GameRules에서 만나 두 흐름이 모두 거치게 되는 데이터에 대한 최종 처리기가 된다.

<br/>

## 흐름 횡단하기

데이터 흐름은 항상 두가지가 아닌 더 추가될 수 있음.

![picture 7](../images/3a5e77b16b36765d61b1304b31295e7393104f247f37879d0770752b632dcb1b.png)

<br/>

## 흐름 분기하기

![picture 8](../images/3ab88a5112d8f3630611966e7e5412b192bf55e362c43f30c856e399e0b3bec3.png)

- 고수준 정책은 플레이어를 관리한다.
- 여기서 MoveManagement와 PlayerManagement를 분리하는 API가 필요할까 ?

<br/>

## 결론

- 아키텍처 경계가 언제 필요한지를 신중하게 파악해야한다.
- 또한 경계를 구현하려면 비용이 드며, 만약 무시되었다면 다시 추가하는 비용이 크다.
- 비용을 산정하여 어디에 아키텍처를 둬야할지, 완벽하게 구현할 경계는 무엇인지와 부분적으로 구현할 경계와 무시할 경계는 무엇인지를 결정해야한다.

<br/>

# 26장. 메인 컴포넌트

## 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준 정책이다.
    - 초기 진입점으로, 어떤것도 메인에 의존하지 않음
    - 시스템 전반을 담당하는 기반을 생성 후 더 높은 수준을 담당하는 부분으로 제어권을 넘김
- 입력 스트림 생성, 게임 메인 루프처리, 간단한 입력 명령어 해석은 main함수에서 처리하지만, 명령어를 실제로 처리하는 일은 다른 고수준 컴포넌트로 위임한다.
- **즉 메인은 클린 아키텍처에서 가장 바깥쪽 원에 위치한 저수준 모듈이다. 메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.**

<br/>

## 결론

- 메인을 애플리케이션의 플러그인이라고 생각하자.
- **메인은 초기 조건과 설정을 구성하고, 외부 자원을 모두 수집한 후, 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인**이다.

<br/>