# 24장. 부분경계
## 부분적 경계
- 아키텍처 경계를 완벽히 만드는데는 비용이 크다.
  - 쌍방향의 Boundary 인터페이스, 입출력 데이터 구조.. 등
  - 이런 방식은 YAGNI 원칙을 위배하기도..  
  

-> 그렇다면 **부분적 경계** 를 구현해볼 수 있다.

> 여기서 YAGNI 원칙은 쉽게 "필요한 작업만 해"라는 뜻

<br/>

## 마지막 단계를 건너뛰기
- 부분적 경계를 생성하는 방법 하나는 **독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행** 한 후, **단일 컴포넌트에 그대로 모아만 둔다.**  -> 모두 단일 컴포넌트로 컴파일해서 배포
- 완벽한 경계를 만들때 만큼의 코드량이 필요하지만, **다수의 컴포넌트를 관리하는 작업** 은 안해도된다. (추적을 위한 버전번호, 배포 관리 부담) 

<br/>

## 일차원 경계
![picture 1](../images/33f361055d819f571e353c56788770d86ceaeda3b5220aca7c9cd434bc76ec7a.png)  

- 완벽한 형태의 경계는 쌍방향 Boundary인터페이스를 유지하지만 비용이 많이 든다.
- 이때 **전통적인 전략패턴** 을 사용할 수 있다.
  - Client를 ServiceImpl로 부터 격리시키는데 필요한 **의존성역전이 적용**됨
  - 추후 완벽한 형태의 경계로 확장할 수 있다.
  - 하지만 제대로 사용하지않으면, 위 점선과 같은 비밀 통로가 생길 수 있음. (이해안감..)

<br/>

## 퍼사드

![picture 2](../images/fcdae60e15f630b20e1cd1b2ce3c0553cfdf5c705270b18a7bb4e454492ba928.png)  


- 경계는 Facade 클래스로만 간단히 정의된다. Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. (클라이언트는 서비스 클래스에 직접 접근 못함)
- 하지만 Client가 추이 종속성 가짐 
  - 서비스 클래스 변경되면 Client도 재컴파일 해야됨
  - 비밀 통로 또한 쉽게 만들어짐
