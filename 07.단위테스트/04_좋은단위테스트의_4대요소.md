# 4장 좋은 단위 테스트의 4대 요소



# 좋은 단위 테스트의 4대 요소 살펴보기

## 첫번째 요소 : 회귀 방지

- 회귀는 **소프트웨어 버그**다. 코드를 수정한 후 기능이 의도한대로 작동하지 않는 경우다.
- 회귀 방지 지표를 극대화 하려면?
  - 테스트가 가능한 한 많은 코드를 실행
  - 코드의 복잡도
  - 코드의 도메인 유의성 

## 두번째 요소 : 리팩터링 내성

- 테스트를 **'빨간색'(실패)로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도**다.
- **거짓 양성**은 **허위 경보**다. 
  - 실제로 **기능이 의도한 대로 작동하지만 테스트는 실패**를 나타내는 결과.
  - 일반적으로 코드를 리팩터링할때, 즉 **구현을 수정하지만 식별할 수 있는 동작은 유지할 때 발생**한다.
- 왜 거짓 양성을 신경써야하는가?
  - 거짓 양성이 빈번하면 신뢰가 서서히 떨어지고, 회귀를 피하려고 코드 변경을 최소화하여 리팩터링이 줄어든다. 또한 타당한 실패도 무시하기 시작해 기능이 고장나도 운영환경에 들어감

### 무엇이 거짓 양성의 원인인가?

- 테스트와 sut의 구현 **세부 사항이 많이 결합할수록 허위 경보**가 더 많이 생긴다.

- 테스트를 통해 **SUT가 제공하는 최종 결과(관련된 절차가 아니라 식별할 수 있는 동작)를 검증하는지 확인**해야한다.

- 테스트 구성하는 좋은 방법은 **문제 영역에 대해 이야기**하는 것이다. 

  - 이러한 테스트가 실패하면, 이야기와 실제 애플리케이션 동작이 서로 분리되는 것을 의미함. -> 도움되는 실패


### 구현 세부 사항 대신 최종 결과를 목표로 하기

- 테스트를 깨지지 않고 리팩터링 내성을 높이는 방법은 **SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는것**이다. 최종 결과를 목표로 해야한다.
  - 어떻게보다 무엇을 중점


# 첫번째 특성과 두번째 특성 간의 본질적인 관계

## 테스트 정확도 극대화 

|             | 기능 작동            | 기능 고장            |
| ----------- | -------------------- | -------------------- |
| 테스트 통과 | 올바른 추론(참음성)  | 2종 오류(거짓 음성)  |
| 테스트 실패 | 1종 오류 (거짓 양성) | 올바른 추론(참 양성) |

- **회귀 방지가 훌륭한 테스트**는 2종 오류의 수를 최소화하는데 도움이됨
- **리팩터링 내성**은 1종오류를 최소화하는데 도움이 된다.
- 초반에는 리팩터링이 바로 중요하지 않고, 시간이 지나며 필요해진다. 이때 리팩터링 내성이 중요. 계속 늑대를 울리면 신뢰를 잃음.
- 따라서 거짓 음성(알려지지 않은 버그)와 거짓 양성(허위 경보)에 대해 똑같이 주의를 기울여야함.

## 세번째, 네번째 요소 : 빠른 피드백과 유지 보수성

- 느린 테스트는 피드백을 느리게 하고 잠재적으로 버그를 뒤늦게 발견해서 버그 수정 비용 증가

# 이상적인 테스트를 찾아서

<img src="https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/23/image-20230423173245479.png" alt="image-20230423173245479" style="width:50%;" />

- 회귀 방지, 리팩터링 내성, 빠른 피드백은 **상호 배타적**이다.

## 극단적 사례 1: 엔드 투 엔드 테스트

- 엔드 투 엔드 테스트는 사용자 관점에서 시스템을 살펴보고, 모든 시스템 요소를 거침
- 회귀 방지 우수 : 많은 코드를 테스트 하므로
- 리팩터링 내성 우수 : 리팩터링은 식별할 수 있는 동작을 변경하지 않으므로 
- 단점은 빠른 피드백을 받기 어렵다.

## 극단적 사례 2: 간단한 테스트

- 너무 단순한 코드 조각에 대한 테스트 (ex. getter, stter)
- 빠른 피드백, 리팩터링 내성도 우수
- 기반 코드에 실수할 여지가 많지 않기 때문에 회귀를 나타내지 않을것이다.

```
    @Test
    fun test() {
        val sut = User("John Smith")

        assertEquals("John Smith", sut.name)
    }
```

## 극단적 사례 3: 깨지기 쉬운 테스트

- 실행이 빠르고, 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트를 작성하기가 매우 쉬운걸 "깨지기 쉬운 테스트"라고 함
- 테스트가 SUT의 내부 구현 세부사항에 결합될때

```
    @Test
    fun test() {
        val sut = UserRepository()

        sut.getById(5)

        assertEquals(
            "SELECT * FROM dbo.[User] WHERE UserID = 5",
            sut.lastExecutedSqlStatement
        )
    }
```

## 이상적인 테스트를 찾아서: 결론

- 세가지 특성은 상호 배타적이다. 한가지를 희생해야만 나머지 두가지를 극대화. 세가지 모두 충족한 테스트는 불가능.
  - 세가지 특성을 모두 양보할 만큼 서로 조금씩 인정하는 것이 최선의 전략.
- 그러나 **유지 보수성과 리팩터링 내성을 최대로 갖도록 노력**해야한다. 따라서 회귀 방지와 빠른 피드백 사이의 선택으로 절충이 귀결된다.
  - 리팩터링 내성은 중간 단계가 없이 있거나 없거나 둘중 하나이기 때문에. 반면 나머지는 조절이 가능함.

# 대중적인 테스트 자동화 개념 살펴보기

![image-20230423174145228](https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/23/image-20230423174145228.png)

## 테스트 피라미드 분해

- 테스트 피라미드는 테스트 스위트에서 테스트 타입 간의 일정한 비율을 일컫는 개념이며 **넓을 수록** 테스트는 많아지고, **높을 수록** 최종 사용자의 동작을 얼마나 유사하게 흉내내는지를 나타낸다.
  - 피라미드 **상단의 테스트**는 회귀 방지에 유리한 반면 **하단은** 실행 속도를 강조한다. 
  - 어느 계층도 **리팩터링 내성을 포기하지 않는다**.
- 예외가 있다. 예를들어 비즈니스 규칙이나 기타 복잡도가 거의 없는 기본 CRUD 작업이라면, 단위 테스트와 통합 테스트의 수가 같은 직사각형 처럼 보일것이다.
  - 단위테스트는 복잡도가 없는 환경에서는 유용하지 않는 반면 통합테스트는 그래도 유용. 따라서 단위테스트보다 통합테스트가 더 많을 수도.

## 블랙박스 테스트와 화이트박스 테스트 간의 선택

- **블랙 박스 테스트**는 시스템의 **내부 구조를 몰라도** 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법. 즉 어떻게 해야하는지가 아니라 무엇을 해야하는지를 중심으로 구축.
- **화이트 박스 테스트** 정반대로 내부 작업을 검증한다. 요구사항이나 명세가 아닌 소스코드에서 파생됨.



(표4.1)

- 리팩터링 내성은 타협할 수 없으므로 모든 테스트를 **블랙박스 테스트를 기본으로 선택**하자. 또 문제 영역에 **의미 있는 동작을 확인**하라.







