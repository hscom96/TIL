# 2장 단위테스트란 무엇인가

# 단위테스트 정의

- **작은 코드 조각**(단위)을 검증하고,
- **빠르게** 수행하고,
- **격리된 방식**으로 진행한다.

처음 두 속성은 논란의 여지가 없지만 세번째 속성에서 의견이 크게 다르다. 이에 따라 고전파, 런던파가 구분됨.

> 고전파의 정의는 단일 동작 단위를 검증하고, 빠르게 수행하고, 다른 테스트와 별도로 처리한다.

## 격리 문제에 대한 런던파의 접근

- 개념

    - 테스트 대상 시스템을 협력자에게서 격리하는것을 일컫는다. 즉, **하나의 클래스가 다른 클래스들에 의존하면 이 모든 의존성을 test double로 대체**해야한다.

- 장점

    - 테스트가 실패하면 코드베이스의 **어느 부분이 고장났는지** 확실히 알 수 있다.
    - **테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도된다.** 
        - 모든 클래스가 각각 직접적인 의존성을 갖고 있으며 또 그 의존성이 또 다른 의존성을 가지고 있는식으로 그래프가 복잡해질 수 있음. .
        - 전체 객체 그래프를 다시 만드는것은? 클래스의 수가 너무 많으면 힘들다.
        - 의존성의 의존성을 다룰 필요도 없다.

    - 전체 단위 테스트 스위트를 **간단한 구조**로 할 수 있다.
        - 테스트 대상 클래스를 의존성에서 분리하면 **각 클래스에 대해 테스트 클래스가 하나씩 있는 구조를 만드는데 도움**준다.

## 격리 문제에 대한 고전파의 접근

- 개념
    - 코드를 꼭 격리하는 방식으로 테스트해야하는 것은 아니다.
    - 대신 **단위 테스트는 격리해서 실행**해야한다.
        - 이렇게 하면 테스트를 어떤 순서로든 가정 적합한 방식으로 실행할 수 있으며 **서로의 결과에 영향을 미치지 않는다.**
    - 테스트 대역을 사용할 수 있지만, 보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용
        - 즉 단위 테스트를 서로 **격리하는 것은 대상 클래스에서 공유 의존성만 격리**하는 것을 의미한다. **비공개 의존성은 그대로 둘 수 있**다.

> 공유 의존성은 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성.  
> ex) static mutable field, 데이터베이스  
> ex) 싱글턴(ex. 설정 클래스)을 각 테스트에서 새 인스턴스를 만들 수 있기만하면 코드에는 단 하나지만, 테스트에서는 재사용하지 않으므로 의존성은 비공개  	

- 공유 의존성을 대체하는 또 다른 이유는 **테스트 실행속도**를 높이는데 있다.
    - 공유 의존성은 거의 항상 실행 프로세스 외부에 있어서 호출하는데 오래 걸린다.
- 단위가 **반드시 클래스에 국한될 필요는 없다.** **공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트**할 수 있다.

## 단위 테스트의 런던파와 고전파

- 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 본다.
- 반면 고전파는 단위 테스트끼리 격리하는 것으로 본다.

|        |  격리 주체  |           단위크기           |    테스트 대역 사용대상    |
| :----: | :---------: | :--------------------------: | :------------------------: |
| 런던파 |    단위     |         단일 클래스          | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 |        공유 의존성         |

## 고전파와 런던파가 의존성을 다루는 방법

- 런던파는 테스트에서 불변 객체는 교체하지 않아도 된다.

> 협력자는 공유하거나 변경 가능한 의존성  
> ex) 숫자 5는 의존성이지만 협력자는 아니다. 값 또는 값객체로 분류된다.  

> 공유 의존성이지만 외부가 아닌 의존성 : 싱글턴  
> 공유 의존성이고 외부 의존성 : 데이터베이스  
> 공유 의존성이 아닌 외부 의존성 : 읽기 전용 API 서비스 (테스트의 속도를 높이려면 테스트 대역으로 교체해야한다)  

## 고전파와 런던파 비교

- 런던파 장점
    - 입자성이 좋다.
        - 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
    - 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.
        - 모든 협력자는 테스트 대역으로 대체되기 때문이다.
    - 테스트가 실패하면 어떤 기능이 실패했는지 확실히알 수 있다.
        - 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른것을 의심할 여지가 없다.

### 한 번에 한 클래스만 테스트하기

- 런던파는 클래스를 단위로 간주한다.

> TIP) **테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위. 즉 문제 영역에 의미가 있는것.** 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. 동작 단위를 구현하는데 클래스가 얼마나 필요한지는 상관없다. 단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 심지어 아주 작은 메서드가 될 수 도 있다.

- 그래서 좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다. **테스트가 단일 동작 단위를 검증하면 좋은 테스트다.**
    - 테스트는 해결하는데 도움이 되는 **문제에 대한 이야기를 들려 줘야하**고, 이 이야기는 일반 사람들에게 응집도가 높고 의미가 있어야한다.

### 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

- 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는데 집중해야한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.
- 목을 사용하는 것은 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.

### 버그 위치 정확히 찾아내기

- 런던파 스타일 테스트가 있는 시스템에 버그가 생기면, 보통 SUT에 버그가 포함된 테스트만 실패

    - 하지만 고전적 방식은 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기한다. -> 문제의 원인을 찾기 더 어려워지고, 디버깅하는데 시간걸림

- 테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다. 즉 마지막으로한 수정이 무엇인지알 기 때문에 문제를 찾는것은 그리 어렵지 않다.

### 고전파와 런던파 사이의 다른 차이점

- 런던파는 하향식 TDD, 고전파는 상향식 TDD
- 런던파는 테스트가 구현에 더 자주 결합되는 편이다.





