# 5장 목과 테스트 취약성

# 목과 스텁 구분

## 테스트 대역 유형

- **목**은 **외부로 나가는 상호 작용**을 **모방하고 검사**한다.
  - 이러한 상호 작용은 SUT가 상**태를 변경하기 위한 의존성을 호출**하는 것에 해당
- **스텁**은 **내부로 들어오는 상호 작용**을 **모방만하고 검사하지 않는다.**
  - 이러한 상호 작용은 SUT가 **입력 데이터를 얻기 위한 의존성을 호출**하는 것에 해당

**![image-20230404001929914](https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/04/image-20230404001929914.png)**

>- 스파이는 목과 같은 역할. 스파이는 수동으로 작성하는 반면. 목은 목프레임워크의 도움을 받아 생성
>- 스텁, 더미, 페이크는 얼마나 똑똑한지에 있다
>  - 더미는 단순하고 하드코딩된 값(null값이거나 가짜 문자열). SUT의 시그니처 메서드를 만족하기 위해 사용
>  - 스텁은 더 정교.  시나리오 마다 다른 값을 반환하게 끔 구성.
>  - 페이크는 대다수의 목적에 부합하는 스텁과 같다. 페이크는 보통 아직 존재하지 안는 의존성을 대체하고자 구현



- 목은 SUT와 관련 **의존성 간의 상호 작용을 모방하고 검사**, 스텁은 **모방만 한다.**

## 스텁으로 상호 작용을 검증하지 말아라.

- SUT에서 스텁으로의 호출은 SUT가 생성하는 최종결과가 아니다. 이러한 호출은 최종 **결과를 산출하기 위한 수단**일뿐. **스텁은 SUT가 출력을 생성하도록 입력을 제공**함
- 거짓 양성을 피하고 리팩터링 내성을 향상 시키는 방법은 **구현 세부 사항이 아니라 최종결과를 검증**해야함.

> **스텁과의 상호작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴**이다

- 목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만, 대다수가 그렇다.

## 목과 스텁은 명령과 조회에 어떻게 

> CQS원칙에 따르면 모든 메서드는 명령과 조회이며, 둘을 혼용해서는 안된다.

![image-20230404001941447](https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/04/image-20230404001941447.png)



# 식별할 수 있는 동작과 구현 세부사항

- 테스트 취약성은 리팩터링 내성에 해당한다.

- 거짓 양성이 있는 주요 이유는 코드 구현 세부사항과 결합됐기 때문. 최종 결과(식별할 수 있는 동작)를 검증해야한다.

## 식별할 수 있는 동작은 공개 API와 다르다.

- 모든 제품 코드는 2차원으로 분류할 수 있다. (각 차원은 둘 다에 속할 수 없다. 겹치지 않음)

  - **공개 API 또는 비공개 API**
  - **식별할 수 있는 동작 또는 구현 세부사항**

- **식별할 수 있는 동작**이란? 아래 중 하나를 해야한다.

  - **클라이언트가 목표를 달성하는데 도움**되는 연산 혹은 상태를 노출하라.

- **구현 세부 사항**은 바로 위 두 가지 중 아무것도 하지 않는다.

- 코드가 **식별할 수 있는 동작인지 여부**는 해당 클라이언트가 누구인지, 그리고 **클라이언트의 목표가 무엇인지에 달려** 있다.

- 잘 설계된 API에서 식별할 수 있는 동작은 공개 API와 일치하는 반면, 모든 구현 세부 사항은 비공개 API 뒤에 숨어있다.

- 공개 API가 식별할 수 있는 동작의 범위를 넘어서면 시스템은 구현 세부사항을 유출한다.

- 클래스가 **구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙**은?

  - 단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부사항을 유출할 가능성이 있다.

  

## 잘 설계된 API와 캡슐화

- 잘 설계된 API를 유지하는 것은 캡슐화 개념과 관련있다.
- 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기때문에 내부를 손상시킬 위험이 적다.
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.



## 구현 세부사항 유출 : 상태의 예

> 모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외에는 다른 선택지가 없으며, 이로 인해 리팩터링 내성도 자동으로 좋아진다. 즉 API를 잘 설계하면 단위 테스트도 자동으로 좋아진다.

- 연산과 상태를 최소한으로 노출하자.
  - 클라이언트가 목표를 달성하는데 직접적으로 도움되는 코드만 공개해야 하며, 다른 모든 것은 구현 세부 사항이므로 비공개 API 뒤에 숨겨야한다.

# 목과 테스트 취약성 간의 관계

## 육각형 아키텍처 정의

- 서로 다른 계층의 테스트는 동일한 동작을 서로 다른 수준으로 검증하는 프랙탈 특성이 있다. 애플리케이션 서비스 테스트는 전반적으로 비즈니스 유스케이스가 어떻게 실행되는지 확인한다. 도메인 클래스 테스트는 유스케이스 완료 방법에 대한 중간의 하위 목표를 검증한다.

(그림 5.10)

- 코드 베이스의 공개 API를 항상 비즈니스 요구사항에 따라 추적하라는 이 지침은 
  대부분의 도메인 클래스와 애플리케이션 서비스에 적용되지만, 유틸리티나 인프라 코드에는 적용되지 않는다.

## 시스템 내부 통신과 시스템 간 통신

- 시스템 내부 통신 : 애플리케이션 내 클래스 간의 통신이다.
  - 구현 세부사항이다.
  - 내부 통신 (내부 클래스 간의 협력)과 결합하면 테스트가 취약해진다.

- 시스템 간 통신 : 애플리케이션이 다른 애플리케이션과 통신하는 것을 말한다.
  - 구현 세부사항이 아니다.
  - 시스템과 통신은 방식은 전체적으로 해당 시스템을 식별할 수 있는 동작을 나타낸다.

- **시스템 내 클래스 간의 통신을 검증하는데 목을 사용하면 테스트가 구현 세부 사항과 결합되며 그에 따라 리팩터링 내성이 미흡**해진다.



#    단위테스트의 고전파 런던파 재고

- 런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부사항에 결합돼 테스트에 리팩터링 내성이 없게된다.
  - 테스트는 외부 시스템 간 통신을 확인 하는것처럼 클래스 간 통신도 확인하기 때문이다.
- 고전파는 테스트 간에 공유하는 의존성 (대부분이 SMTP 서비스나 메시지 버스 등 프로세스 외부 의존성에 해당)만 교체하자고 하므로 더 유리하다.

## 모든 프로세스 외부 의존성을 목으로 해야하는 것은 아니다.

> - 공유 의존성 : 테스트 간에 공유하는 의존성
> - 프로세스 외부 의존성 : 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 하는 의존성 (ex. 데이터베이스, 메시지버스, SMTP 서비스)
> - 비공개 의존성 : 공유하지 않는 모든 의존성

> - 공유 의존성이 프로세스 내부에 있으면 각 테스트 실행 시 해당 의존성을 새 인스턴스로 써서 재사용 피하기 쉬움
> - 공유 의존성이 프로세스 외부에 있으면 각 테스트 실행전 db를 인스턴스화하거나 메시지버스를 새로 준비할 수 없다. (이렇게하면 너무 느려짐) -> 일반적인 접근은 테스트 대역, 즉 목과 스텁으로 교체한다.



- **모든 프로세스 외부 의존성을 목으로 해야하는 것은 아니다**.

  - 프로세스 외부 의존성과 통신은 **외부에서 관찰할 수 없으면 구현 세부사항** 이다. 즉 프로세스 외부 의존성이 애플리케이션을 통해서만 접근 가능하다면, 이러한 의존성과 통신은 시스템에서 식별할 수 있는 동작이 아니다. 리팩터링 후에 그대로 유지할 필요가 없으므로 목으로 검증해서는 안된다. 
  - ex) DB -> 피드백 속도를 저하시키나 6장, 7장에서 이 주제를 다룸

- **완전히 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트**로 이어진다.

  

  

  ## 목을 사용한 동작 검증

  - 종종 목이 동작을 검증한다고 한다. 하지만 대부분 그렇지 않다. 
  - 목표를 달성하고자 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과는 아무런 관계가 없다. (이는 구현 세부사항이다.)
  - **목은 어플리케이션의 경계를 넘나드는 상호작용을 검증할 때와 이러한 상호작용의 사이드 이펙트가 외부 환경에서 보일 때만 동작과 관련**이 있다.

  

