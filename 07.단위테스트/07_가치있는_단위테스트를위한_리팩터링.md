# 7장 가치 있는 단위테스트를 위한 리팩터링

# 리팩터링할 코드 식별하기

## 코드의 네가지 유형

모든 제품 코드는 2차원으로 분류할 수 있다.

- **복잡도 또는 도메인 유의성**
    - 복잡도는 코드내 의사 결정(분기) 지점 수로 정의
    - 도메인 유의성은 코드가 프로젝트 문제 도메인에 얼마나 의미 있는지
    - 복잡한 코드와 도메인 유의성을 갖는 코드가 회귀 방지에 뛰어나서 단위 테스트에 이롭다.
- **협력자 수**
    - 협력자가 많으면 테스트도 커져서 테스트 비용이 많이 든다. (유지보수성 지표때문)
    - 협력자 유형도 중요. 도메인 모델은 외부 협력자를 사용하면 안됨. 또한 리팩터링 내성을 지키려면 신중하게 목을 사용.

<img src="https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/23/image-20230423162859419.png" alt="image-20230423162859419" style="width:50%;" />

코드는 4가지 유형이 있다.

- **도메인 모델과 알고리즘**
    - 복잡하거나 중요한 로직을 수행해서 테스트의 회귀 방지가 향상 되기 떄문에 가치있다.
    - 코드에 협력자가 거의 없어서 테스트 유지비를 낮추기 때문에 저렴하다.

- **간단한 코드**
    - 테스트할 필요가 전혀 없다. 가치가 0에 가깝다.

- **컨트롤러** : 복잡하거나 비즈니스에 중요한 작업을 하는 것이 아니라 도메인 클래스와 외부 애플리케이션 같은 다른 구성 요소의 작업을 조정한다.
- **지나치게 복잡한 코드**
    - 지나치게 복잡한 코드를 알고리즘과 컨트롤러로 나눠서 리팩터링하라.

> 코드가 더 중요해지거나 복잡해질 수록 협력자는 적어야한다.

> 좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다.

## 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

- 지나치게 복잡한 코드를 쪼개려면 험블객체(humble object)패턴을 써야한다.

![image-20230423193532614](https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/23/image-20230423193532614.png)

- 테스트 대상 코드의 로직을 테스트하려면, **테스트가 가능한 부분을 추출**해야 한다. (추출된 로직은 다른 클래스로 이동) 결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 험블 래퍼가 된다.
    - 이 험블 래퍼가 테스트학 어려운 의존성과 새로 추출된 구성요소를 붙이지만, 자체적인 로직이 거의 없거나 전혀 없으므로 테스트할 필요가 없다.

![image-20230423193715434](https://raw.githubusercontent.com/hscom96/ImageStore/main/images/2023/04/23/image-20230423193715434.png)

- 육각형 아키텍처, 함수형 아키텍처 모두 정확히 이 패턴을 구현한다.
    - 육각형 아키텍처는 비지니스 로직과 프로세스 외부 의존성과의 통신을 분리한다. 이는 도메인 계층과 애플리케이션 서비스 계층이 각각 담당하는 것이다.
    - 함수형 아키텍처는 더 나아가 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 커뮤니케이션에서 비즈니스 로직을 분리한다. (테스트를 더 용이하게함) 즉, 함수형 코어에는 아무런 협력자도 없다. 함수형 코어의 모든 의존성은 불변
- 험블 객체를 보는 또 다른 방법은 **단일 책임 원칙**이다.
    - 이는 각 클래스가 단일한 책임만 가져야 한다는 원칙이다. 그러한 책임 중 하나로 늘 비지니스 로직이 있는데, 이 패턴을 적용하면 비지니스 로직을 거의 모든 것과 분리할 수 있다.

# 요약

