# 6장 단위테스트 스타일



# 단위 테스트의 세가지 스타일



## 출력  기반 테스트 정의

- 출력 기반 테스트는 시스템이 생성하는 **출력을 검증**한다. 
- 숨은 입출력이 없다고 가정하고(사이드 이펙트가 없고), SUT 작업의 결과는 반환하는 값뿐이다.
- 출력 기반 단위 테스트 스타일은 함수형이라고도 한다. 

## 상태 기반 테스트 정의

- 상태 기반 스타일은 **작업이 완료된 후 시스템 상태를 확인**하는 것이다.
- 상태 라는 용어는 SUT나 협력자 중 하나, 또는 데이터베이스 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수도 있다.

## 통신 기반 테스트 정의

- SUT의 협력자를 목으로 대체하고 SUT가 협력자를 올바르게 호출하는지 검증한다.

> 고전파는 통신기반 스타일보다 상태 기반 스타일을 선호. 런던파는 이와 반대로 선택한다. 두분파는 출력 기반 테스트를 사용한다.



# 단위 테스트 스타일 비교

> 4 대요소 (회귀방지, 리팩터링 내성, 빠른 피드백, 유지 보수성)



## 회귀 방지와 피드백 속도 지표로 스타일 비교하기

- 회귀 방지는 스타일별로 차이가 없다.
  - 회귀 방지는 테스트 중에 실행되는 코드양, 코드 복잡도, 도메인 유의성에 결정됨
- 피드백 속도는 스타일별로 차이가 없다.

## 리팩터링 내성 지표로 스타일

- **출력 기반 테스트**는 테스트가 테스트 대상 메서드에만 결합되므로 **거짓 양성 방지가 가장 우수**하다.
  - 이런 테스트가 구현 세부 사항에 결합되는 경우는 테스트 대상 메서드가 구현 세부사항일때뿐이다.
- **상태 기반 테스트**는 일반적으로 **거짓 양성이 되기 쉽다.**
  - 이러한 테스트는 테스트 대상 메서드 외에도 클래스 상태와 함께 작동.
  - 확률적으로 테스트와 제품 코드간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성 큼
- **통신 기반 테스트**는 **허위 경보에 가장 취약**하다.
  - 테스트 대역으로 상호 작용을 확인 하는 테스트는 대부분 깨지기 쉬움
  - 스텁과 상호작용을 확인해서는 안된다.
  - 애플리케이션 경계를 넘는 상호 작용을 확인해야 하고, 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮다.

## 유지 보수성 지표로 스타일 비교 하기

> - 두가지 특성
>   - 테스트를 이해하기 얼마나 어려운가? (테스트 크기)
>   - 테스트 실행하기 얼마나 어려운가? (외부 의존성 개수)

- 출력 기반 테스트
  - 가장 유지보수하기 용이
- 상태 기반 테스트
  - 일반적으로 출력기반테스트보다 유지보수가 쉽지 않다.
  - 종종 출력 검증보다 더 많은 공간을 차지하기 때문이다.
- 통신 기반 테스트
  - 유지보수가 가장 안좋다.
  - 테스트 대역과 상호 작용 검증을 설정해야해서 공간 많이 차지한다.

## 결론

- 항상 다른것보다 출력 기반 테스트를 선호하라.
- 하지만 객체지향 언어에는 행하기 어려운데 출력기반 테스트로 변경하는 기법이 있다.

# 함수형 아키텍처 이해

## 함수형 프로그래밍이란?

- 출력 기반 단위 테스트 스타일은 함수형이라고도 한다.
- 함수형 프로그래밍은 수학적 함수(순수 함수)를 사용한 프로그래밍이다.
  - 수학적 함수는 숨은 입출력이 없는 함수다.
  - 수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다.

- 순수 입출력 유형
  - 사이드 이펙트 : 사이드 이펙트는 메서드 시그니처에 표시되지 않은 출력이며, 따라서 숨어있다. (연산은 클래스 인스턴스의 상태를 변경하고 디스크 파일을 업데이트 하는 등 사이드 이펙트 발생)
  - 예외 : 메서드가 예외를 던지면, 프로그램 흐름에 시그니처에 설정된 계약을 우회하는 경로를 만든다.
  - 내외부 상태에 대한 참조 : DateTime.Now와 같이 현재 날짜 가져오는 메서드가 있을 수 있는데, 모두 메서드 시그니처에 없는 실행 흐름에 대한 입력이며 숨어져있다.



## 함수형 아키텍처란?

어떤 사이드 이펙트도 일으킬 수 없는 애플리케이션을 만들 수는 없고 비현실적이다. 

함수형 프로그래밍의 목표는 사이드 이펙트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 **사이드 이펙트를 일으키는 코드를 분리**하는것이다.

- 두가지 코드 유형을 구분해서 분리 가능
  - **결정을 내리는 코드** (함수 코어): 이 코드는 사이드 이팩트가 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
    - 함수형 코어는 수학적 함수를 사용해 구현되며 애플리케이션에서 모든 결정을 내린다.
  - **해당 결정에 따라 작용하는 코드** (가변 셸): 이코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터 베이스 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.
    - 함수형 코어에 입력 데이터를 제공하고 데이터 베이스와 같은 프로세스 외부 의존성에 사이드 이펙트를 적용해 그 결정을 해석한다.
- 함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.
  - 가변 셸은 모든 입력을 수집한다.
  - 함수형 코어는 결정을 생성한다.
  - 셸은 결정을 사이드 이펙트로 변환한다.

목표는 출력 기반 테스트로 함수형 코어를 두루 다루고, 가변 셸을 훨씬 더 적은수의 통합 테스트에 맡기는 것이다. 



## 함수형 아키텍처와 육각형 아키텍처의 비교 

- 공통점
  - 육각형 아키텍처는 도메인 계층과 애플리케이션 서비스 계층을 분리. 결정과 실행을 분리하는 함수형 아키텍처와 유사
  - 의존성 간의 단방향 흐름
- 차이점
  - 사이드 이펙트에 대한 처리에 있다.
    - 함수형 아키텍처는 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장 자리로 밀어낸다. 이 가장자리는 가변 셸이 처리
    - 육각형 아키텍처는 도메인 계층에 제한하는 한, 도메인 계츠으로 인한 사이드 이펙트도 문제없다. 육각형 아키텍처의 모든 수정 사항은 계층의 경계를 넘어서는 안된다. 예를들어 도메인 클래스 인스턴스는 데이터베이스에 직접 저장할 수 없지만, 상태는 변경할 수있다. 애플리케이션에서 이 변경 사항을 데이터베이스에 적용한다.

> 함수형 아키텍처는 육각형 아키텍처의 하위 집합이다. 극단적으로는 함수형 아키텍처를 육각형 아키텍처로 볼 수 있다.



# 함수형 아키텍처의 단점 이해하기 

## 함수형 아키텍처 적용 가능성

> 함수형 코어 클래스는 협력자로 작동하면 안되고, 작업의 결과인 값으로 작동해야한다.
>
> - 협력자란 다음 중 하나에 해당하는 의존성
>   - 가변 
>   - 아직 메모리에 있지 않는 데이터에 대한 프록시(공유의존성)