# 리펙터링 [마틴파울러 저]

> 책 읽고 기억하고 싶은 구절 메모 📖

<br/>

<p align="center">
<img alt="picture 10" src="../images/Book/%EB%A6%AC%ED%8E%99%ED%84%B0%EB%A7%81/63d12e2048390883c60324b3a31b5a04ebcf37ed99ffacc548fae3733d2ca06a.png" width="125px">  
</p>



# 리팩터링 원칙

## 리펙터링 정의

> 리펙터링이란 소프트웨어의 **겉보기 동작은 그대로 유지**한 채,   
> **코드를 이해하고 수정하기 쉽도록 내부 구조를 변경**하는 기법이다.

여기서 겉보기 동작이란 리펙터링하기 전과 후의 코드가 똑같이 동작해야한다는 뜻이다.

- 물론 완전히 똑같은 동작은 아니다.
- 예를들어 함수 추출하기같은 경우 콜스택이 변화해서 성능이 변할수도있다.
- 하지만 **사용자 관점**에서 달라지는 점이 없어야한다.

결국 리펙터링은 동작을 보존하는 **작은 단계들을 거쳐 코드를 수정**하고, 이러한 단계들을 순차적으로 연결하여 **큰 변화**를 만들어내는 일이다.

## 성능최적화?

- 기능을 유지한채 코드를 변경한다는 점은 동일하다.
- 하지만 **리팩터링의 목적은 코드를 이해하고 수정하기 쉽게**만드는것이다.
    - 프로그램 **성능은 좋아질 수도, 나빠질 수도**있다.
- 반면 **성능 최적화는 오로지 속도 개선**만 신경쓴다.

---

## 작업 구분

개발할때 현재 **목적이 '기능 추가'인지, '리펙터링'인지 명확히 구분하여 작업**하자.

- 기능 추가할때?
    - 기존 코드는 절대 건들이지 말고 새 기능을 추가하기만 하자.
- 리펙터링
    - 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념
    - 테스트도 새로 만들지 않는다. (놓친 테스트 제외)

---

## 리펙터링하는 이유

#### 리팩터링하면

1. **소프트웨어 설계가 좋아진다.**
    1. 단기적 목표만을 위해 코드를 수정하다보면 기반 구조가 무너지기 쉽고, 코드만 봐서 설계를 파악하기 어렵다.
    2. 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
2. **소프트웨어를 이해하기 쉬워진다.**
3. **버그를 쉽게 찾을 수 있다.**
4. **프로그래밍 속도를 높일 수 있다.**
    1. 리팩터링하는데 시간이 드니 전체 개발속도가 떨어지지는 않는지?
        1. 새로로운 기능을 추가할수록 기존 코드에 잘 녹여낼 방법을 찾는데 드는 시간이 늘어난다.
        2. 하지만 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지 쉽게찾을 수 있다.

---

## 언제 리펙토링을 할까?

1. 준비를 위한 리팩터링 - 기능을 쉽게 추가하게 만들기
    1. 가장 좋은 시점은 코드베이스에 **기능을 새로 추가하기 직전**이다.
    2. 구조를 살짝 바꾸면 다른 작업 하기가 훨씬 쉬워질 만한 부분을 찾는다.
2. 이해를 위한 리팩터링
    1. **코드를 파악할 때마다** 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
        1. 파악했던 세부사항은 기억력의 한계로 오래 기억하지 못한다.
        2. 리팩터링을 하면 머리로 이해한것을 코드에 옮겨 닮을 수 있다.
3. 쓰레기 줍기 리팩터링
    1. 수정하려면 오래걸리고 당장은 급한일이 있을 수 있다.
    2. 이때 간단히 수정할 수 있는것은 즉시 고치고, 시간이 걸리는 일은 짧은 메모를 남기고 이후에 진행한다.
4. **리팩토링하지 말아야 할 때**
    1. 지저분한 코드를 발견할때 굳이 수정할 필요가 없다면 하지 않는다.
        1. 외부 api다루듯 호출해서 쓰는 코드라면 그냥둔다.
        2. 내부동작 이해해야할 시점에 리팩터링해야 효과를 볼 수 있다.
    2. 처음부터 새로 작성하는게 더 쉬울때 하지않는다.

---

## 리팩터링, 아키텍처, 애그니

- 기존에는 일단 코드로 작성된 뒤로는 아키텍처를 바꿀 수 없다는 관점이 있었다.
- 하지만 **리팩터링은 아키텍처를 바라보는 관점**을 바꿔놓았다.
- 수년동안 운영되던 소프트웨어라도 **아키텍처를 대폭 변경할 수 있다.**
- **아키텍처를 확정지을때의 대표적인 문제**는 **소프트웨어 요구사항을 사전에 모두 파악**해야한다.
- 하지만 사전에 모두 파악을 못하고 나중에서야 정말 원하는 바를 알게되는 경우가 허다하다.

변경에 유연하게 대처할 수 있는 방법은

- 첫번째로 **유연성 매커니즘**을 소프트웨어에 심어두는 것이다.
    - 예를 들어 다양한 예상 시나리오에 범용적으로 사용하기 위해서 함수를 정의시에 매개변수를 추가한다.
    - 하지만, 매개변수를 추가하다보면 당장의 쓰임에 비해서 **함수가 너무 복잡**해진다.
    - 즉, 모든 상황을 고려하다 보면 유연성 매커니즘이 오히려 변화에 대응하는 능력을 떨어뜨린다.

- 그렇다면 **리팩토링을 활용하면 된다.**
    - **어느 부분에 유연성이 필요하고 어떻게 그 변화에 잘 대응할 수 있을지 추측하지 않는다.**
    - **현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축**한다.
    - 진행하면서 **요구사항을 더 잘 이해하게되면 아키텍처도 그에 맞게 리팩터링**해서 바꾼다.
        - 예를 들어, 호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다.
        - 매개변수 추가해야할 시점이 오면 '함수 매개변수화하기 11-2절'로 해결한다.
    - 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들때만 유연성 매커니즘을 미리 추가한다.

이런 식으로 설계하는 방식을 **간결한 설계, 점진적 설계, YAGNI(애그니)(**"you aren't going to need it" 필요없을것이다.)

라고 부른다.

---

## 리팩터링과 성능

**리펙터링하면 소프트웨어가 느려질 수도 있는 건 사실**이다. 하지만 그와 **동시에 성능을 튜닝하기는 더 쉬워진다**.

**먼저 튜닝하기 쉽게 만들고나서 원하는 속도가 나게끔 튜닝하**는 것이다.

성능에 대한 흥미로운 사실은, **대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비**한다.

그래서 코드 전체를 고르게 최적화한다면 그중 **90%는 효과가 거의 없기 때문에** **시간낭비**인 셈이다.

'90%의 시간은 낭비'라는 통계에서 착안해서,

- 의도적으로 성능 최적화에 돌입하기 전까지는 **성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중**한다.
- 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다.
    - 그러면 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있다.
    - 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 큰효과를 본다.

<br/>

# 코드에서 나는 악취

리펙터링을 **언제 시작하고 언제 그만할지를 판단하는 일**은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.

여기서 **냄새란 리팩터링할 시점을 뜻한다**.

1. 기이한 이름
    - 함수, 모듈, 변수, 클래스 등은 **이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야**한다.
2. 중복 코드
    - 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합할 수 있다.
    - 코드가 중복되면 하나를 변경할때 다른 비슷한 코드도 모두 살펴보고 적절히 수정해줘야하는 부담 생긴다.
3. 긴 함수
    - 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할때 나온다.
    - 예전 언어는 서브루틴 호출하는 비용이 커서 짧은 함수를 꺼렸다.
        - 하지만 **요즘 언어는 프로세스 안에서 함수 호출비용을 거의 없애버렸다**.
    - 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. -> 적극적으로 함수를 쪼개자.
    - **주석을 달아야 할 만한 부분은 함수로 만든다.**
        - 함수 이름은 동작방식이 아닌 의도, 코드의 목적을 드러내야한다.
        - **무엇을 하는지 코드가 잘 설명해주지 못할수록 함수로 만드는 것이 유리**
        - 코드가 단 한 줄이여도 설명할 필요가 있으면 함수로 추출하는 게 좋다.
4. 긴 매개변수 목록
    - **클래스는 매개변수 목록을 줄이는데** 효과적인 수단.
        - 특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용
5. 전역 데이터
    - 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다.
6. 가변 데이터
    - 코드의 다른 곳에서는 다른 값을 기대한 다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다.
        - 이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지않고, 변경하려면 반드시 (원래 데이터는 그대로 둔채) **변경하려는 값에 해당하는 복사본을 만들어서 반환**한다.
7. 뒤엉킨 변경
    - 소프트웨어는 구조를 변경하기 쉬운 형태로 개발되어야 한다.
        - 수정할 때는 고쳐야 할 딱 한 군데를 차아서 그 부분만 수정한다.
    - **뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때** 나타난다.
        - 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을때 발생한다.
        - 예를들어, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생
8. 산탄총 수술
    - 뒤엉킨 변경과 비슷하면서 정반대
        - 원인
            - (공통) 맥락을 잘 구분하지 못함
        - 해법(원리)
            - (공통) 맥락을 명확히 구분
        - 발생 과정(현상)
            - 뒤엉킨 변경 : 한코드에 섞여 들어감
            - 산탄총 수술 : 여러 코드에 흩뿌려짐
        - 해법(실제행동)
            - 뒤엉킨 변경 : 맥락별로 분리
            - 산탄총 수술 : 맥락별로 모음
    - **코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을때** 생긴다.
9. 기능 편애
    - 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 **다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을때** 풍기는 냄새다.
10. 데이터 뭉치
    - 데이터 항목 서너개가 여러곳에서 항상 뭉쳐 다니는 모습을 흔히 목격할 수 있다.
        - 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다.
    - **데이터 뭉치인지 판단하려면** 값 하나를 삭제해보자.
        - 그랬을 때 **나머지 데이터만으로는 의미가 없다면** 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻
11. 기본형 집착
    - 프로그래밍 언어는 정수, 부동소수점 수, 문자열 같은 다양한 기본형을 제공한다.
    - 프로그래머 중에는 자신에게 **주어진 문제에 딱 맞는 기초 타입(화폐,좌표,구간 등)을 직접 정의**하기 꺼리는 사람이 많다.
        - 그래서 금액을 그냥 숫자형으로 계산하거나,
        - 물리량을 계산할 때도 밀리미터나 인치 같은 단위를 무시하고, 범위도 if(a<upper && a > lower) 처럼 처리한다.
12. 반복되는 switch문
    1. **filter나 map 같은 파이프라인 연산**을 사용하며 ㄴ코드에서 각 원소들이 어떻게 처리 되는지 쉽게 파악 가능하다.
13. 반복문
14. 성의 없는 요소
    - 우리는 코드의 구조를 잡을 때 프로그램 요소를 이용하는 것을 좋아한다.
        - \*코드구조 : 프로그래밍 언어가 제공하는 함수, 클래스, 인터페이스 등 코드 구조를 잡는데 활용되는 요소
    - 하지만 그 구조가 필요없을때도 있다.
        - 본문 코드를 그대로 쓰는 것과 진배없는 함수도 있고실질적으로 메서드가 하나뿐인 클래스도있다.
        - 이런 구조는 나중에 본문을 더 채우거나 다른 메서드를 추가할 생각이지만 그렇지 못했을때
        - 혹은 풍성했던 클래스가 리팩터링을 거치면서 역할이 줄어듬
    - 이러한 구조는 제거하자.
15. 추측성 일반화
    - **'나중에 필요할 거야'라는 생각**으로 **당장은 필요 없는** 모든 종류의 **후킹 포인트와 특이 케이스 처리 로직**을 작성해둔 코드에서 풍긴다.
    - 그 결과는 물론 이해하거나 관리하기 어려워진 코드
    - 미래를 대비해 작성한 부분을 실제로 사용한다면 다행이지만, 그렇지 않는다면 쓸데없는 낭비
16. 임시 필드
    - 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.
        - 하지만 겍체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통
        - 이렇게 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.
        - 사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악하느라 힘들다.
17. 메시지 체인
    - **클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식**으로, **다른 객체를 요청하는 작업이 연쇄적으로** 이어지는 코드를 말한다.
        - getSometing() 같은 **게터가 꼬리에 꼬리를 물고 이어지**거나 임시 변수들이 줄줄이 나열되는 코드가 있다.
        - 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.
18. 중개자
    - 캡슐화하는 과정에서는 **위임(delegation)이 자주 활용**된다.
        - 예를 들어 팀장에게 미팅을 요청한다고 하자. 팀장은 자신의 일정을 확인한 후 답을 준다. 이러면 끝이다. 팀장이 종이 다이어리를 쓰든, 일정 서비스를 쓰든, 따로 비서를 두든 우리는 알 바 아니다.
    - 하지만 **지나치면 문제가**된다.
        - 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면?
        - 이럴때는 **중개자 제거하기**(7.8절)을 활용하여 **실제로 일을 하는 객체와 직접 소통**하게 한다.
19. 내부자 거래
    - 개발자는 **모듈 사이의 데이터 거래가 많으면 결합도가 높아진다고 한다**.
        - 일이 돌아가게 하려면 거래가 이루어질 수 밖에없지만, 그 **양을 최소로 줄이고** 모두 **투명하게 처리**해야 한다.