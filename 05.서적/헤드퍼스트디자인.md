# 헤드퍼스트 디자인

# 전략패턴

## 개념

- (책설명)알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
- (내설명) 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여, 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는
  방법을 말합니다. 간단히 말해서 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴입니다.

## 상속의 단점

- **서브 클래스에서 코드가 중복된다.**
- 모든 오리의 행동을 알기 어렵다.
- 실행 시에 특징을 바꾸기 어렵다.
- 코드를 변경했을때 다른 오리들에 원치않은 영향을 끼칠 수 있다.
- 메서드 하나를 추가하는데 구현해야되는 클래스가 있고, 안 구현해도 되는 클래스가 있는데 모두 구현해야한다

## 개선 방향

**디자인** **원칙** **:** **달라지는** **부분을** **찾아내고**, **달라지지** **않는** **부분과** **분리한다.**

- 바뀌는 부분은 캡슐하, 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.
- 시스템 일부분을 다른 부분과 독립적으로 변화시킬 수 있다.
- 나는행동, 꽥 행동 -> 달라지는 부분 -> 별도의 행동으로 캡슐화 분리

**디자인** **원칙** **:** **구현보다는** **인터페이스에** **맞춰서** **프로그래밍**

- 실제 쓰이는 객체가 코드에 고정되지 않도록 상위 형식에 맞춰 프로그래밍해서 다형성을 활용해야 한다는점이 핵심

**디자인** **원칙** **:** **상속보다는** **구성을** **활용한다**.

- 유연성을 크게 향상시킴
- 알고리즘군을 별도의 클래스 집합으로 캡슐화할 수 있다.
- 구성요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행 시에 행동을 바꿀 수 있다.

## Reference

- https://victorydntmd.tistory.com/292

# 옵저버 패턴

## 개념

- 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
    - 의존하지 않으면서 통지 가능

## 디자인 원칙

- 상호 작용하는 객체 사이에는 가능하면 **느슨한 결합**을 사용해야한다.

## 장점

- 객체간의 **결합도 느슨**해짐. 상호 의존성을 최소화.
- OCP을 지킬 수 있음.

## reference

- https://jiseok-zip.tistory.com/entry/iOS%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4Observer-Pattern

# 데코레이터 패턴

- 주어진 상황 및 용도에 따라 **어떤 객체에 책임(기능)을 동적으로 추가**하는 패턴
- 서브클래스를 만들때 보다 훨씬 유연하게 기능 확장할 수 있다.

## 디자인 원칙

- OCP : 클래스는 확장에는 열려 있어야하지만 변경에는 닫혀있어야한다.

## 장점

- **기존 코드를 수정하지 않고도** **행동을 확장**시킬 수 있습니다.
- 구성과 위임을 통해서 **실행중에 새로운 행동을 추가**할 수 있습니다.

## 단점

- **의미없는 객체들이 너무 많이 추가**될 수 있음.
- 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해질수도
- 구상클래스 사용하는곳에선 힘듬

## 사용시기

- 클래스의 요소들을 계속해서 수정을 하면서 사용하는 구조가 필요한 경우
- 여러 요소들을 조합해서 사용하는 클래스 구조인 경우

## reference

- https://coding-factory.tistory.com/713
- https://gmlwjd9405.github.io/2018/07/09/decorator-pattern.html