# 1장. 왜 NoSQL 인가?

## 객체-관계 불일치

- 즉 관계형 모델과 메모리 내 데이터 구조간 차이 존재. 그 결과 메모리 내 데이터 구조를 그대로 디스크에 저장하는 새로운 DB 필요성
  - 관계형 튜플 안의 값은 중첩된 레코드나 리스트등 다른 구조를 포함할 수 없다. 그 결과 메모리 내 데이터 구조를 DB에 저장하려면 관계형 표현으로 변환해야한다. (여러 테이블의, 여러 행으로 쪼개짐..)
- ORM으로 객체-관계 불일치는 완화됐지만, 매핑 문제는 여전히 논쟁 거리 

## 클러스터 필요성

- 트래픽이 증가함에 따라 수직, 수평 확장을 고려해야함.
  - 수직 확장은 장비를 키우는데 한계도 있고, 비쌈
  - 수평확장, 클러스터는 저가 하드웨어로 구축할 수 있어서 비용이 훨씬 적게 든다. 또 장비가 한대 실패해도 중단없이 서비스하도록 높은 가용성 제공 가능
- 하지만 관계형DB는 클러스터에서 동작하도록 설계되지 않음.
  - 샤딩을 할 수 있지만, 애플리케이션에서 모든 샤딩을 제어해야해서 부자연스러움. (여러 샤드에 걸친 쿼리 같은것도 못하기도..)

# 2장. 집합적 데이터 모델

- 데이터 모델이란? 데이터베이스가 **데이터를 구조화**하는 모델 (ex. 관계형 데이터 모델)

## 집합 (aggregate)

- **집합(aggregate)은 단위로 사용하는 데이터 모음**이다. (**함께 접근하는 데이터**를 한 덩어리로 모아놓음) (데이터 접근 단위)데이터 베이스 **ACID 연산에 대한 경계를 형성**함
- **집합의 경계는 데이터 조작하는 방식에 따라 완전히 다르다**. 예를들어 고객 데이터에 접근할때 그 고객의 주문 정보도 한꺼번에 접근하는 경우가 대부분이라면 단일 집합이 좋다. 반면 주문을 개별로 처리하길 원한다면 각각을 별도의 집합으로 분리하는 것이 좋다.  
  - **만약 다양한 데이터 조작 방법이 필요한 경우라면 집합 무지 모델이 더 좋은 선택이다. (원하는 데이터를 얻으려고 집합을 다 헤집고 다녀야함)** 
- 집합을 사용하면 **클러스터**에서 동작하기 쉽다. 한 집합으로 구성된 데이터는 모두 한 노드에 저장됨을 데이터베이스가 보장함.
  - 데이터를 수집할때 질의해야 하는 노드 수를 최소화 해야한다. 명시적으로 집합을 포함 시키면 어떤 데이터를 함께 조작해야하는지에 대한 중요한 정보를 데이터베이스에 제공해 이런 데이터를 동일한 노드에 저장하도록 할 수 있음.
- 그래프 DB는 집합 무지이다. 키-값 모델, 문서, 칼럼-패밀리 DB는 집합 지향 데이터베이스다.
- 집합 지향 데이터베이스에서는 여러 집합을 포괄하는 ACID 트랜잭션을 지원하지 않는다. 대신, **한번에 단일 집합에 대해서만 원자성을 지원**한다. 
  - 집합 여러개를 원자적 방법으로 조작하려면 어플리케이션 코드로 직접 처리해야한다.

## 키-값 모델과 문서 데이터 모델

- 키-값 저장소에서는 키를 통해서만 집합에 접근할 수 있다. (집합의 일부로 쿼리 할 수 없다.)
- 문서 데이터베이스에서는 문서 내부 구조를 기초로 어떤 형태의 쿼리를 실행한다.
  - 집합의 필드를 이용해 질의를 하거나, 집합의 전체 대신 일부를 조회할 수 있으며, 집합의 내용을 이용해 인덱스를 만들 수 있다.

# 3장. 데이터 모델 상세

## 관계

- 집합 지향도 DB에 관계를 보이도록 하는 방법을 제공
  - 관련 데이터를 다르게 접근하는 경우 한 덩어리로 모아놓기 보다 독립된 집합으로 모델링하고 싶을 수 있다. 이때 서로의 ID를 포함시켜 관계를 표현할 수 있는 방법이 있는데 DB는 이런 데이터 사이의 관계를 모른다. 
  - DB가 이런 연결을 알면 유용한 경우가 있고, DB에 관계를 보이도록 하는 방법을 제공한다.  (ex. 문서 저장소는 집합의 내용을 가지고 DB가 인덱스를 만들고 조회할수있게함)
- 원자성은 단일 집합에서만 지원 (복수 집합에 대해서는 직접 처리해야함)
- 즉, **집합 지향 DB는 여러 집합에 걸친 데이터 조작 불편**하다. (조인의 부재, 트랜잭션 관리)
  - 데이터 사이 많은 관계가 있다면 관계형 DB를 사용하는게 나을 수 있다. 하지만 관계형 DB도 복잡한 관계를 처리하는데 아주 뛰어나지 않음. 조인이 늘어나면 SQL 작성, 성능면에서 안좋음

## 그래프 데이터베이스

- **그래프 데이터베이스는 복잡한 관계를 가지는 데이터에 최적**
  - 그래프 데이터베이스에서 관계를 따라가는 연산은 매우 적다. (관계형은 join 많을수록 성능 안좋음)
  - 그래프 데이터베이스는 클러스터보다는 단일 서버에서 실행되는 경우가 많다.

## 스키마 없는 데이터베이스

- 스키마가 없는 DB를 사용하더라도, 보통은 애플리케이션 코드에 암묵적 스키마가 있다. 
  - **무스키마 데이터 베이스를 사용하면 스키마가 데이터베이스에서 애플리케이션 코드로 이동한다.**
- 암묵적 스키마 문제점
  - 어떤 데이터가 있는지 확인 하려면 애플리케이션 코드를 파봐야함. 구조화가 잘 된 코드라면 스키마를 추론할 수 있는 명확한 위치를 찾을 수 있다. 하지만 그런 보장은 없다.
  - DB는 스키마에 대해 모르기 때문에, 스키마 정보를 활용해 효율적으로 데이터를 저장하고 꺼낼 수 없다.
  - 여러 애플리케이션이 데이터를 비일관적으로 조작하지 않는지 확인하기 위한 데이터 유효성 검사도 못함

## 구체화 뷰

- 데이터를 다른 방법으로 접근하고자할때 관계형 데이터베이스는 집합 구조가 없어서 쉬우므로 유리
  - 더군다나 뷰를 통해 데이터를 저장되어 있는것과 다른 형태로 쉽게 볼 수 있다. 
- 집합지향 DB는 주요 집합과 구조가 다른 데이터 제공을 위해 구체화 뷰를 사용한다.
  - 기본 데이터가 바뀔때 구체화 뷰도 함께 바뀌도록 하는 방법 (쓰기보다 읽기가 훨씬 많고, 구체화 뷰가 최신 데이터를 가져오고자 할때)
  - 규칙적인 간격으로 배치 작업을 실행해 구체화 뷰를 업데이트 하는 방법

# **ChatGPT 답변**

### 하나의 Aggregate로 만드는 경우

1. **장점**:
   - **데이터 일관성**: 주문과 관련된 상품 정보가 동일한 aggregate 내에 있으면, 데이터의 일관성을 유지하기 쉽습니다. 예를 들어, 주문 취소 시 상품 재고를 업데이트하는 것이 하나의 트랜잭션 내에서 처리될 수 있습니다.
   - **성능 향상**: 관련 데이터가 같은 위치에 저장되어 있기 때문에, 데이터를 조회할 때 더 빠른 응답 시간을 기대할 수 있습니다.
2. **단점**:
   - **확장성 제한**: 주문과 상품 데이터가 많아지면, 하나의 aggregate가 너무 커질 수 있으며, 이는 성능 저하와 확장성 문제를 야기할 수 있습니다.
   - **유연성 감소**: 다른 컨텍스트에서 상품 정보만 필요한 경우에도 항상 주문 데이터와 함께 로드되어야 하므로, 불필요한 데이터 로드가 발생할 수 있습니다.

### 별도의 Aggregate로 만드는 경우

1. **장점**:
   - **확장성**: 각 aggregate가 독립적으로 관리되므로, 시스템의 확장성이 더 용이합니다. 상품과 주문 정보를 별도로 확장하고 최적화할 수 있습니다.
   - **유연성**: 상품이나 주문 정보가 독립적으로 필요한 경우, 각각을 개별적으로 조회하고 관리할 수 있어, 다양한 비즈니스 요구사항에 더 잘 대응할 수 있습니다.
2. **단점**:
   - **데이터 일관성 유지의 어려움**: 예를 들어, 주문 취소 시 상품 재고를 업데이트하는 것과 같은 작업을 처리하기 위해서는 복잡한 트랜잭션 관리나 보상 로직이 필요할 수 있습니다.
   - **조회 성능 저하**: 여러 aggregate에 걸쳐 있는 데이터를 조회할 때, 여러 네트워크 호출이 필요하며, 이는 전체 시스템의 응답 시간에 영향을 줄 수 있습니다. (조인의 부재)



# 4장 분산 모델

## 샤딩

- 샤딩은 여러 서버에 데이터를 나눠 분산한다. 각 서버는 전체 데이터의 부분 집합을 저장하며 같은 데이터는 한 서버에서만 찾을 수 있다.
- **집합은 하나의 데이터를 뭉쳐놓을 수 있어서 한 사용자가 한 서버로 부터 데이터를 대부분 얻게 할 수** 있다. (분산의 아주 좋은 단위가 됨)
- 데이터를 접근이 발생하는 지역에 가깝게 두면 성능 향상에 도움됨
- 집합을 모든 노드에 균등하게 분산하고 같은 양의 부하가 걸리도록 해야한다.
- 이전에는 샤딩을 어플리케이션 로직으로 처리했으나, 많은 **NoSQL이 각 샤드에 할당하고 데이터 접근할때 올바른 샤드에 접근하도록 하는 책임인 자동 샤딩을 지원**한다.
- 샤딩은 **읽기와 쓰기 성능을 모두 향상**시킬수 있다.
  - 복제는 읽기 성능을 높이지만, 쓰기 성능 향상이 거의 없다.
  - **샤딩은 쓰기에 대한 수평 확장 방법을 제공**
- 샤딩 단독으로 사용하는 경우 resilience(복원력)이 오히려 줄어든다. (클러스터는 보통 신뢰성 낮은 저가 장비로 구성해서 노드 하나가 실패하는 경우가 잦다)

## 마스터-슬레이브 복제

- 마스터는 데이터의 믿을 만한 출처가 되고, 업데이트를 처리할 책임 가진다. 읽기는 마스터 또는 슬레이브 어디에서든 처리 가능하다. 복제 프로세스는 슬레이브를 마스터와 동기화 한다.
- **읽기 확장성에 도움이 되지만 쓰기 확장성에는 도움이 되지 않는다.**
  - 쓰기 트래픽은 읽기 트래픽을 슬레이브에 넘겨 쓰기 부하를 처리하는데 약간 도움을 받을 수 있지만, 좋은 구성이라고 할 수는 없다.
- **슬레이브 실패에 대해서는 복원력을 제공하지만, 마스터 실패에 대해서는 복원력을 제공하지 못한다. (여전히 마스터는 병목이고 단일 실패지점)**
  - 마스터가 실패하더라도 슬레이브가 읽기 요청을 처리할 수 있다. (마스터가 다시 살아날때까지 쓰기 처리할 능력은 사라짐.) 하지만 마스터가 슬레이브에 복제되어 있고 슬레이브 하나가 즉시 새로운 마스터로 지정될 수 있으므로 빠르게 복구 가능하다.
- **비일관성** : 변경 사항이 모든 슬레이브에 전파되기 전에, 서로 다른 클라이언트가 서로 다른 슬레이브에서 읽어 서로 다른 값을 볼 수 있는 위험이 있다. 최악의 경우 한 클라이언트에서 자신이 쓴 데이터를 읽지 못하는 사태도 있음. (처리 방법은 나중에 살펴봄)

## 피어-투-피어 복제

- 개념
  - 마스터를 두지 않는 구조. 모든 노드에서 모든 데이터를 읽고 쓸 수 있다. 노드간 쓰기 데이터를 주고 받는다.
- 모든 노드에서 쓰기 요청을 처리해서, 노드 중 어느것이 실패하더라도 데이터 저장소에 대한 접근이 중단되지 않는다. 또한 쉽게 노드를 추가해 성능을 향상 시킬수있음.
- 비일관성 : 다른 두 노드에서 두 사람이 동시에 동일한 레코드를 업데이트하려는 쓰기 충돌 위험에 처할 수 있다. (처리 방법은 나중에 살펴봄).
- 비일관적 쓰기를 허용해서 최대 성능 효과를 낼수도 있다. 

**정리하자면 마스터-슬레이브 복제는 업데이트 충돌 발생을 줄인다. 피어-투-피어 복제는 한 노드에 모든 쓰기 부담을 지우지 않도록 해서 단일 실패 지점이 생기지 않도록한다.**

## 샤딩과 복제의 결합

- 복제와 샤딩은 결합될 수 있다.



# 5장 일관성

## 업데이트 일관성

- 쓰기 충돌은 두 클라이언트가 동시에 같은 데이터를 쓰려할때 발생한다.
- 비관적 방법은 충돌을 방지하려고 데이터 레코드에 쓰기 잠금을 사용한다. 낙관적 방법은 충돌이 발생하도록 놔두고 충돌을 탐지해 해결한다.
- **단일 시스템에선 데이터에 대한 쓰기를 단일 노드에서 처리하므로 비관적, 낙관적 방법이 통하고, 업데이트 일관성 유지하기가 쉽다.**. 하지만 **피어-투-피어 복제처럼 서버가 한대 이상이라면, 두 노드가 업데이트를 다른 순서로 적용할 수 있고, 그 결과 각 노드마다 다른 전화번호를 가질 수 있다. 즉 특별한 조치를 취하지 않는 이상 충돌이 발생**
  - 사람들이 분산 시스템에서 동시성을 말할때는 보통 모든 노드가 같은 순서로 연산을 적용하는 것이 보장되는 순차적 일관성을 뜻하는것이다.
- 비관적 접근법은 안정성은 높지만 응답성을 심각하게 저해한다. 또 dead lock 발생 가능성도 있다.

## 읽기 일관성

-  **읽기-쓰기 충돌(비일관적 읽기)**은 한 클라이언트가 쓰고 있는 도중에 다른 클라이언트가 비일관적 데이터를 읽을 때 발생한다. 

- **트랜잭션**

  - **논리적 일관성**은 다른 데이터 항목이 함께 의미를 가지도록 보장하는것을 뜻한다.
  - 논리적으로 비일관적인 읽기-쓰기 충돌을 피하기 위해서 **관계형 데이터베이스는 트랜잭션**을 지원한다. (두 테이블의 쓰기를 한 트랜잭션은 다른 사용자는 둘다 업데이트 전이나, 업데이트된 이후 데이터를 읽는다.) 
    - NoSQL 중 집합 지향 데이터베이스만 트랜잭션이 없고, 그래프 데이터베이스는 트랜잭션을 지원한다.
  - 집합 지향 데이터베이스는 **한 집합에 대해서만 원자적 업데이트를 지원**한다. 
    여러 집합에 영향을 미치는 업데이트가 있는 경우 클라이언트가 **비일관적 읽기**를 수행하 수 있다. 
    비일관성이 존재하는 시간의 길이를 **비일관성 윈도**라고 한다.

- **분산 시스템에서의 읽기-쓰기 충돌(비일관적 읽기)**

  - **복제 일관성**는 같은 데이터 항목을 다른 복제본에서 읽어도 같은 값임을 보장하는 것이다.  분산 시스템에 **읽기-쓰기 충돌**이 발생하는 것은 일부 노드는 업데이트를 받았지만 다른 노드는 받지 못한 시점이 있기때문이다. 
  - **결과적 일관성**은 특정 시점에는 노드에 복제 일관성 불일치가 있을 수 있지만, 결국에는 모든 노드가 같은 값으로 업데이트될 것임을 뜻한다.
  - 비일관성 윈도의 크기가 커지면 논리적 일관성이 악화될 수 있다. 마스터에서는 두 건의 업데이트가 연속해서 빠르게 실행 되기 때문에 비일관성 윈도가 수 밀리 초에 불과하다. 그러나 **슬레이브에서는 네트워크 지연 때문에 비일관성 윈도가 훨씬 더 길어**질 수 있다.

- **세션 일관성**

  - 자신이 방금 업데이트한 내용을 조회하고자 했으나 업데이트가 안된 노드로 요청이 가서 조회가 안되는 문제가 있을 수있다. 결과적 일관성을 사용하는 시스템에서 이를 방지 하는것이 **세션 일관성, 즉 사용자 세션 내에서 자신이 쓴것에 대한 일관성을 제공**하는 것이다.

  - 해결방법

    - **Sticky Session**은 자신이 쓴것에 대한 일관성은 보장이 된다. 단점은 부하 분산이 제대로 되지 않을 수 있다.

      - Sticky Session과 마스터-슬레이브 복제로 세션 일관성 달성하는 방법. (부하를 위해 슬레이브는 읽기만, 쓰기는 마스터에서 수행해야할 경우) 
        - 첫번째 방법 : 쓰기를 슬레이브로 보내되 슬레이브가 클라이언트에 대한 세션 일관성을 유지하면서 쓰기를 마스터로 전달하게 하는것이다. 
        - 두번째 방법 : 쓰기를 할때만 임시로 세션을 마스터로 전환해 슬레이브가 마스터의 업데이트를 모두 따라잡을 때까지만 읽기도 마스터에서 수행하게 하는 것이다.

    - **버전 스태프**는 데이터 저장소와의 모든 상호작용에 세션이 사용한 가장 최근 버전 스탬프를 포함하도록 하는것이다.

      

## 일관성 완화

- 다른 특성을 위해 일관성을 완화할때도 있음
- CAP 정리
  - 일관성 (Consistncy), 가용성 (Availability), 분단 허용성 (Partition tolerance) 세가지중 두가지만 가질 수 있다는 것이다.
  - **가용성** : 클러스터의 한 노드와 통신할 수 있으면 그 노드에서 읽기와 쓰기가 가능해야한다. 실패해서 응답하지 않는 노드는 CAP에서 가용하지 않은 상태라 할 수 없다. (가용성에 대한 CAP에서의 특별한 정의)
  - **분단 허용성**: 클러스터가 서로 통신할 수 없게 되더라도 클러스터가 잘 동작해야한다.