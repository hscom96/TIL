# Chapter 4. 스트림 소개

# 스트림이란?

**데이터 처리 연산**을 지원하도록 **소스**에서 추출된 **연속된 요소** 다.

> - 연속된?
    >
- **순서와 상관없이 아무 값에나 접속하는 것이 아니라 순차적으로 값에 접근**한다는 것을 의미

- **연속된 요소**
    - 컬렉션과 마찬가지로 **스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스 제공**
    - **컬렉션의 주제는 데이터, 스트림의 주제는 계산**이다.
        - 컬렉션은 자료구조 이므로 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룸 (ArayList를 사용할지, LinkedList를 사용할지)
- **소스**
    - 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비
    - 컬렉션으로 스트림 생성하면 정렬이 그대로 유지
- **데이터 처리 연산**
    - 함수형 프로그래밍에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.
    - 스트림 연산은 순차적 또는 **병렬로 실행**가능

# 주요 특징

- **파이프라이닝**
    - 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 **스트림 자신을 반환**한다.
    - **게으름(laziness), 쇼트서킷(short-circuiting)**같은 최적화도 얻을 수 있다.

- **내부반복**
    - 반복자를 이용해 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복 지원

# 스트림과 컬렉션

- 스트림, 컬렉션의 가장 큰 차이는?  **"데이터를 언제 계산하느냐"**
    - 컬렉션
        - 컬렉션은 현재 자료구조가 포함하는 **모든 값을 메모리에 저장**하는 자료구조
        - 연산 수행(컬렉션에 요소를 추가, 삭제 등)할때마다 컬렉션의 **모든 요소를 메모리에 저장**해야 하고, 컬렉션에 추가하려는 요소는 **미리 계산**이 되어야한다.
        - **적극적(eager)으로 생성**된다 (생산자 중심 : 팔기도 전에 창고를 가득 매움)
    - 스트림
        - **요청할 때만 요소를 계산**하는 고정된 자료구조 (스트림에 요소를 추가하거나 제거할 수 없다.)
        - **게으르게(lazy) 만들어지는 컬렉션**. 즉 사용자가 데이터를 요청할 때만 값을 계산한다.

## 스트림은 딱 한 번만 탐색할 수 있다.

- (= 단 한번만 소비할 수 있음)
- 반복자와 마찬가지로 다시 탐색 하려면 초기 데이터 소스에서 새로운 스트림을 만들어야한다.

## 외부 반복과 내부 반복

- 외부 반복
    - 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 패턴
    - ex) for문, Iterator를 활용하는 While문 등등
    - 병렬성을 스스로 관리해야함
- 내부 반복
    - 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야할 코드만 제공
    - 이점
        - 컬렉션 내부에서 어떻게 반복시킬 것인가는 컬렉션에 맡겨두고, 개발자는 요소 처리 코드에만 집중
        - 요소들의 반복순서를 변경하거나, 멀티코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 병렬 작업시킬 수 있게 도와줌

# 스트림연산

```java
List<Stirng> names = menu.stream() // 스트림 open
		.filter(dish -> dish.getCalories > 300) // 중간 연산 시작
		.map(Dish::getname)
		.limit(3) // 중간 연산 끝, short-circuit
		.collect(toList()); // 종단 연산
```

## 중간연산

- 단말 연산을 스트림 파이프라인에 시랭하기 전까지는 아무 연산도 수행하지 않는다. 즉 게으르(lazy)하다.
- **게으른 특성으로 인한 최적화 효과**
    - 300 칼로리가 넘는 요리는 여러개지만 오직 처음 3개만 선택됨.**(쇼트서킷)**
    - filter와 map은 서로 다른 연산이지만 한 과정으로 병합됨.(루프 퓨전)



