# 아이템 28_2. 추가조사정리 - 제네릭

## 제네릭 장점 정리

- 컴파일타임때 타입 체킹해준다.
    - 런타임때 에러생기는것보다 찾기 쉬움
- 타입 캐스팅을 제거함
- 제네릭을 이용하면 다양한 타입에서 동작하는 알고리즘을 구현할 수 있다. (+type safe)

## 타입파라미터 네이밍 컨벤션

1. E - Element (used extensively by the Java Collections Framework)
2. K - Key
3. N - Number
4. T - Type
5. V - Value
6. S,U,V etc. - 2nd, 3rd, 4th types

## 자바 컴파일러 타입소거 규칙

#### `Unbounded Type(<?>, <T>)`은 `Object`로 변환한다.

- 컴파일 할 때 (타입 소거 전)

```java
public class Node<T> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}

```

- 런타임 때 (타입 소거 후)

```java
public class Node {

    private Object data;
    private Node next;

    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Object getData() { return data; }
    // ...
}

```

#### `Bound Type(<E extends Comparable>)`의 경우 `Object`가 아닌 `Comparable`로 변환한다.

- 컴파일 할 때 (타입 소거 전)

```java
public class Node<T extends Comparable<T>> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```

- 런타임 때 (타입 소거 후)

```java
public class Node {

    private Comparable data;
    private Node next;

    public Node(Comparable data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Comparable getData() { return data; }
    // ...
}
```

#### 확장된 제네릭 타입에서 다형성 보존을 위해 어떠한 클래스나, 인스턴스를 상속 혹은 구현할때 bridge method를 생성한다.

```java
public class Node<T> {
    public T data;
    public Node(T data) { this.data = data; }
    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
```

- 컴파일 할 때 (타입 소거 전)

```java
public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

- 런타임 때 (타입 소거 후)

```java
public class MyNode extends Node {

    // Bridge method generated by the compiler
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
    // ...
}
```

- bridge 메서드는 type erasure 이후 Node 클래스에서의 setData메서드와 같은 이름의 메서드를 가지고 원래의 setData 메서드의 역할을 대신한다.

#### 타입 안정성 보존을 위해 필요하다면 type casting을 넣어준다.

#### 제네릭 타입을 사용할 수 있는 일반 class, interface, method에만 소거 규칙을 적용한다.

<br/>

## 읽어보면 좋은 Refrence

- https://velog.io/@guswns3371/%EC%A0%9C%EB%84%A4%EB%A6%AD
- https://jyami.tistory.com/99
- 제네릭, 상속, 하위타입
    - https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html
- 제네릭 타입소거
    - https://docs.oracle.com/javase/tutorial/java/generics/erasure.html
