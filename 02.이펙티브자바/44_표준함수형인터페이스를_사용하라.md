# 아이템 44. 표준 함수형 인터페이스를 사용하라

> - 람다가 지원되면서 상위 클래스의 기본메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 보다
> - 이를 대체하는 해법은 같은효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공
## 함수형 인터페이스
- 필요한 용도에 맞는게 있다면, 직접 구현하지 말고 표준함수형 인터페이스를 활용하자.

|종류|추상메서드 특징|
|:-:|:-:|
|Consumer|- 매개값은 있고, 리턴값은 없음|
|Supplier|- 매개값은 없고, 리턴값은 있음|
|Function|- 매개값도 있고, 리턴값도 있음 </br> - 주로 매개값을 리턴값으로 매핑(타입변환)|
|Operator|- 매개값도 있고, 리턴값도 있음 </br> - 주로 매개값을 연산하고 결과를 리턴|
|Predicate|- 매개값은 있고, 리턴 타입은 boolean </br> - 매개값을 조사해서 true/false 리턴|

- 위 6가지 함수형 인터페이스의 자세한 타입들은 너무 많아 아래 출처로 대체하겠다.
  - 자세한 타입 URL : https://velog.io/@ansalstmd/%EC%9D%B4%EA%B2%83%EC%9D%80-%EC%9E%90%EB%B0%94%EB%8B%A4-14%EC%9E%A5%EB%9E%8C%EB%8B%A4%EC%8B%9D


<br/>

## 직접 작성하는 경우
#### 아래 3가지 중 하나를 만족하면 전용 함수형 인터페이스를 구현해야 하는건지 고민
> - ex) Comparator

1. 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
2. 반드시 따라야할 규약이 있다.
3. 유용한 디폴트 메서드를 제공할 수 있다.

<br/>

## 주의사항
#### 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자
- 계산량이 많을때 성능이 처참하게 느려질 수 있다.
#### 표준 인터페이스 중 필요한 용도에 없을때 직접작성
- ex) 매개변수 3개받는 Predicate 등등..
#### 직접 만든 함수형 인터페이스에는 항상 `@FunctionalInterface` 애너테이션을 사용하라
```java
@FunctionalInterface
public interface MyFunctionalInterface {
  public int method(int x, int y);
}
```
1. 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설게된 것임을 알려준다.
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 한다.
3. 그 결과 유지 보수과정에서 실수로 메서드를 추가하지 못하게 막아준다.
#### 서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 다중정의를 피하자.
- 클라이언트에게 모호함을 주고 문제가 생길 수 있음
